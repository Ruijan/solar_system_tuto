"use strict";(self.webpackChunksolar_system=self.webpackChunksolar_system||[]).push([[7294],{7294:(e,t,n)=>{n.r(t),n.d(t,{default:()=>p});var a=n(5043),r=n(3336),s=n(6446),o=n(5865),i=n(1906),u=n(5475),l=n(1021),c=n(579);const p=()=>((0,a.useEffect)((()=>{const e=JSON.parse(localStorage.getItem("completionStatus")||"{}");e.lecture3=!0,localStorage.setItem("completionStatus",JSON.stringify(e))}),[]),(0,c.jsx)(r.A,{style:{padding:16},children:(0,c.jsxs)(s.A,{my:4,children:[(0,c.jsx)(o.A,{variant:"h4",component:"h1",gutterBottom:!0,children:"Lecture 3: Data Structures in Python"}),(0,c.jsx)(o.A,{variant:"body1",paragraph:!0,children:"In this lecture, we will explore data structures in Python, such as lists, dictionaries, sets, and tuples. These structures are crucial for organizing and managing data in a program. They allow you to store collections of related data and provide various ways to access and manipulate these collections."}),(0,c.jsx)(o.A,{variant:"h5",component:"h2",gutterBottom:!0,children:"Lists"}),(0,c.jsx)(o.A,{variant:"body1",paragraph:!0,children:"A list is a collection of items that can be of any type. Lists are ordered, meaning that the items have a defined order, and you can access elements by their position in the list. Lists are changeable, allowing you to add, remove, or modify elements. They also allow duplicate members, so the same value can appear multiple times. Lists are very versatile and can be used to store related items such as a collection of planet names."}),(0,c.jsx)(l.Rc,{text:"\n# Creating a list\nplanets = [\"Mercury\", \"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\", \"Neptune\"]\nprint(planets)\n# Output: ['Mercury', 'Venus', 'Earth', 'Mars', 'Jupiter', 'Saturn', 'Uranus', 'Neptune']\n\n# Accessing elements\nprint(planets[0])  # Output: Mercury\nprint(planets[-1])  # Output: Neptune\n\n# Adding elements\nplanets.append(\"Pluto\")\nprint(planets)  # Output: ['Mercury', 'Venus', 'Earth', 'Mars', 'Jupiter', 'Saturn', 'Uranus', 'Neptune', 'Pluto']\n\n# Removing elements\nplanets.remove(\"Pluto\")\nprint(planets)  # Output: ['Mercury', 'Venus', 'Earth', 'Mars', 'Jupiter', 'Saturn', 'Uranus', 'Neptune']\n                    ",language:"python",theme:l.f$,codeBlock:!0}),(0,c.jsx)(o.A,{variant:"h5",component:"h2",gutterBottom:!0,children:"Dictionaries"}),(0,c.jsx)(o.A,{variant:"body1",paragraph:!0,children:"A dictionary is a collection of key-value pairs. Each key is unique, and it is associated with a value. Dictionaries are unordered, meaning that the items do not have a defined order, but you can access elements by their keys. Dictionaries are changeable, so you can add, remove, or modify key-value pairs. They are very useful for storing data that can be associated with unique keys, such as the number of moons each planet has."}),(0,c.jsx)(l.Rc,{text:"\n# Creating a dictionary\nplanet_moons = {\n    \"Mercury\": 0,\n    \"Venus\": 0,\n    \"Earth\": 1,\n    \"Mars\": 2,\n    \"Jupiter\": 79,\n    \"Saturn\": 83,\n    \"Uranus\": 27,\n    \"Neptune\": 14\n}\nprint(planet_moons)\n# Output: {'Mercury': 0, 'Venus': 0, 'Earth': 1, 'Mars': 2, 'Jupiter': 79, 'Saturn': 83, 'Uranus': 27, 'Neptune': 14}\n\n# Accessing values\nprint(planet_moons[\"Earth\"])  # Output: 1\n\n# Adding key-value pairs\nplanet_moons[\"Pluto\"] = 5\nprint(planet_moons)  # Output: {'Mercury': 0, 'Venus': 0, 'Earth': 1, 'Mars': 2, 'Jupiter': 79, 'Saturn': 83, 'Uranus': 27, 'Neptune': 14, 'Pluto': 5}\n\n# Removing key-value pairs\ndel planet_moons[\"Pluto\"]\nprint(planet_moons)  # Output: {'Mercury': 0, 'Venus': 0, 'Earth': 1, 'Mars': 2, 'Jupiter': 79, 'Saturn': 83, 'Uranus': 27, 'Neptune': 14}\n                    ",language:"python",theme:l.f$,codeBlock:!0}),(0,c.jsx)(o.A,{variant:"h5",component:"h2",gutterBottom:!0,children:"Sets"}),(0,c.jsx)(o.A,{variant:"body1",paragraph:!0,children:"A set is a collection of unique items. Sets are unordered, meaning that the items do not have a defined order, and you cannot access elements by their position. Sets are changeable, allowing you to add or remove elements. They are particularly useful for storing collections of unique items, such as a list of unique planet names without duplicates."}),(0,c.jsx)(l.Rc,{text:"\n# Creating a set\nunique_planets = {\"Mercury\", \"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\", \"Neptune\"}\nprint(unique_planets)\n# Output: {'Mercury', 'Venus', 'Earth', 'Mars', 'Jupiter', 'Saturn', 'Uranus', 'Neptune'}\n\n# Adding elements\nunique_planets.add(\"Pluto\")\nprint(unique_planets)  # Output: {'Mercury', 'Venus', 'Earth', 'Mars', 'Jupiter', 'Saturn', 'Uranus', 'Neptune', 'Pluto'}\n\n# Removing elements\nunique_planets.remove(\"Pluto\")\nprint(unique_planets)  # Output: {'Mercury', 'Venus', 'Earth', 'Mars', 'Jupiter', 'Saturn', 'Uranus', 'Neptune'}\n                    ",language:"python",theme:l.f$,codeBlock:!0}),(0,c.jsx)(o.A,{variant:"h5",component:"h2",gutterBottom:!0,children:"Tuples"}),(0,c.jsx)(o.A,{variant:"body1",paragraph:!0,children:"A tuple is a collection of items that can be of any type. Tuples are ordered and unchangeable, meaning that once a tuple is created, you cannot add, remove, or modify elements. Tuples allow duplicate members. They are useful for storing related items that should not change, such as coordinates or RGB color values."}),(0,c.jsx)(l.Rc,{text:"\n# Creating a tuple\nplanet_position = (\"Earth\", 3)\nprint(planet_position)\n# Output: ('Earth', 3)\n\n# Accessing elements\nprint(planet_position[0])  # Output: Earth\nprint(planet_position[1])  # Output: 3\n                    ",language:"python",theme:l.f$,codeBlock:!0}),(0,c.jsx)(o.A,{variant:"h5",component:"h2",gutterBottom:!0,children:"Nested Data Structures"}),(0,c.jsx)(o.A,{variant:"body1",paragraph:!0,children:"You can nest data structures within each other to create complex data models. For example, a list can contain dictionaries, and a dictionary can contain lists. This allows you to represent more complex relationships. For instance, you might use a dictionary to represent a solar system, where each key is a planet and the value is a list of its moons."}),(0,c.jsx)(l.Rc,{text:'\n# Nested data structures\nsolar_system = {\n    "Mercury": [],\n    "Venus": [],\n    "Earth": ["Moon"],\n    "Mars": ["Phobos", "Deimos"],\n    "Jupiter": ["Io", "Europa", "Ganymede", "Callisto"],\n    "Saturn": ["Titan", "Enceladus", "Mimas", "Dione"],\n    "Uranus": ["Miranda", "Ariel", "Umbriel", "Titania", "Oberon"],\n    "Neptune": ["Triton", "Nereid"]\n}\n\nfor planet, moons in solar_system.items():\n    print(f"Planet: {planet}")\n    for moon in moons:\n        print(f" - Moon: {moon}")\n                    ',language:"python",theme:l.f$,codeBlock:!0}),(0,c.jsx)(o.A,{variant:"h5",component:"h2",gutterBottom:!0,children:"Nested Dictionaries"}),(0,c.jsx)(o.A,{variant:"body1",paragraph:!0,children:"Nested dictionaries are dictionaries within dictionaries. This structure allows you to store more complex data relationships. For example, you might have a dictionary where each key is a planet, and the value is another dictionary containing attributes about that planet."}),(0,c.jsx)(l.Rc,{text:'\n# Nested dictionaries\nsolar_system = {\n    "Mercury": {"moons": 0, "orbit": 0.39},\n    "Venus": {"moons": 0, "orbit": 0.72},\n    "Earth": {"moons": 1, "orbit": 1.00, "details": {"mass": 5.97, "radius": 6371}},\n    "Mars": {"moons": 2, "orbit": 1.52},\n    "Jupiter": {"moons": 79, "orbit": 5.20},\n    "Saturn": {"moons": 83, "orbit": 9.58},\n    "Uranus": {"moons": 27, "orbit": 19.22},\n    "Neptune": {"moons": 14, "orbit": 30.05}\n}\n\nfor planet, attributes in solar_system.items():\n    print(f"Planet: {planet}")\n    for attribute, value in attributes.items():\n        print(f" - {attribute}: {value}")\n                    ',language:"python",theme:l.f$,codeBlock:!0}),(0,c.jsx)(s.A,{mt:4,children:(0,c.jsx)(i.A,{variant:"contained",color:"primary",component:u.N_,to:"/week1/lecture3/questionnaire",children:"Take the Questionnaire"})})]})}))}}]);
//# sourceMappingURL=7294.82d6fc1a.chunk.js.map